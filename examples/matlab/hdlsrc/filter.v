// -------------------------------------------------------------
//
// Module: filter
// Generated by MATLAB(R) 9.4 and Filter Design HDL Coder 3.1.3.
// Generated on: 2022-03-03 12:56:36
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Code Generation Options:
//
// FIRAdderStyle: tree
// AddPipelineRegisters: on
// TargetLanguage: Verilog
// TestBenchStimulus: impulse step ramp chirp noise 
// GenerateHDLTestBench: off

// -------------------------------------------------------------
// HDL Implementation    : Fully parallel
// Folding Factor        : 1
// -------------------------------------------------------------
// Filter Settings:
//
// Discrete-Time FIR Filter (real)
// -------------------------------
// Filter Structure  : Direct-Form FIR
// Filter Length     : 11
// Stable            : Yes
// Linear Phase      : Yes (Type 1)
// -------------------------------------------------------------




`timescale 1 ns / 1 ns

module filter
               (
                clk,
                clk_enable,
                reset,
                filter_in,
                filter_out
                );

  input   clk; 
  input   clk_enable; 
  input   reset; 
  input   [63:0] filter_in; //double
  output  [63:0] filter_out; //double

////////////////////////////////////////////////////////////////
//Module Architecture: filter
////////////////////////////////////////////////////////////////
  // Local Functions
  // Type Definitions
  // Constants
  parameter coeff1 = 5.4174207548884135E-02; //double
  parameter coeff2 = 6.0265300478235466E-02; //double
  parameter coeff3 = 6.5332513632768000E-02; //double
  parameter coeff4 = 6.9136864819462310E-02; //double
  parameter coeff5 = 7.1495886578512774E-02; //double
  parameter coeff6 = 7.2295212175775378E-02; //double
  parameter coeff7 = 7.1495886578512774E-02; //double
  parameter coeff8 = 6.9136864819462310E-02; //double
  parameter coeff9 = 6.5332513632768000E-02; //double
  parameter coeff10 = 6.0265300478235466E-02; //double
  parameter coeff11 = 5.4174207548884135E-02; //double

  // Signals
  real delay_pipeline [0:10] ; // double
  real product11; // double
  real product10; // double
  real product9; // double
  real product8; // double
  real product7; // double
  real product6; // double
  real product5; // double
  real product4; // double
  real product3; // double
  real product2; // double
  real product1; // double
  real sum_final; // double
  real sum1_1; // double
  real sumpipe1_1; // double
  real sum1_2; // double
  real sumpipe1_2; // double
  real sum1_3; // double
  real sumpipe1_3; // double
  real sum1_4; // double
  real sumpipe1_4; // double
  real sum1_5; // double
  real sumpipe1_5; // double
  real sumpipe1_6; // double
  real sum2_1; // double
  real sumpipe2_1; // double
  real sum2_2; // double
  real sumpipe2_2; // double
  real sum2_3; // double
  real sumpipe2_3; // double
  real sum3_1; // double
  real sumpipe3_1; // double
  real sumpipe3_2; // double
  real sum4_1; // double
  real sumpipe4_1; // double
  real output_typeconvert; // double
  real output_register; // double

  // Block Statements
  always @( posedge clk or posedge reset)
    begin: Delay_Pipeline_process
      if (reset == 1'b1) begin
        delay_pipeline[0] <= 0.0000000000000000E+00;
        delay_pipeline[1] <= 0.0000000000000000E+00;
        delay_pipeline[2] <= 0.0000000000000000E+00;
        delay_pipeline[3] <= 0.0000000000000000E+00;
        delay_pipeline[4] <= 0.0000000000000000E+00;
        delay_pipeline[5] <= 0.0000000000000000E+00;
        delay_pipeline[6] <= 0.0000000000000000E+00;
        delay_pipeline[7] <= 0.0000000000000000E+00;
        delay_pipeline[8] <= 0.0000000000000000E+00;
        delay_pipeline[9] <= 0.0000000000000000E+00;
        delay_pipeline[10] <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_pipeline[0] <= $bitstoreal(filter_in);
          delay_pipeline[1] <= delay_pipeline[0];
          delay_pipeline[2] <= delay_pipeline[1];
          delay_pipeline[3] <= delay_pipeline[2];
          delay_pipeline[4] <= delay_pipeline[3];
          delay_pipeline[5] <= delay_pipeline[4];
          delay_pipeline[6] <= delay_pipeline[5];
          delay_pipeline[7] <= delay_pipeline[6];
          delay_pipeline[8] <= delay_pipeline[7];
          delay_pipeline[9] <= delay_pipeline[8];
          delay_pipeline[10] <= delay_pipeline[9];
        end
      end
    end // Delay_Pipeline_process


  always @* product11 <= delay_pipeline[10] * coeff11;

  always @* product10 <= delay_pipeline[9] * coeff10;

  always @* product9 <= delay_pipeline[8] * coeff9;

  always @* product8 <= delay_pipeline[7] * coeff8;

  always @* product7 <= delay_pipeline[6] * coeff7;

  always @* product6 <= delay_pipeline[5] * coeff6;

  always @* product5 <= delay_pipeline[4] * coeff5;

  always @* product4 <= delay_pipeline[3] * coeff4;

  always @* product3 <= delay_pipeline[2] * coeff3;

  always @* product2 <= delay_pipeline[1] * coeff2;

  always @* product1 <= delay_pipeline[0] * coeff1;

  always @* sum1_1 <= product11 + product10;

  always @* sum1_2 <= product9 + product8;

  always @* sum1_3 <= product7 + product6;

  always @* sum1_4 <= product5 + product4;

  always @* sum1_5 <= product3 + product2;

  always @ (posedge clk or posedge reset)
    begin: temp_process1
      if (reset == 1'b1) begin
        sumpipe1_1 <= 0.0000000000000000E+00;
        sumpipe1_2 <= 0.0000000000000000E+00;
        sumpipe1_3 <= 0.0000000000000000E+00;
        sumpipe1_4 <= 0.0000000000000000E+00;
        sumpipe1_5 <= 0.0000000000000000E+00;
        sumpipe1_6 <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          sumpipe1_1 <= sum1_1;
          sumpipe1_2 <= sum1_2;
          sumpipe1_3 <= sum1_3;
          sumpipe1_4 <= sum1_4;
          sumpipe1_5 <= sum1_5;
          sumpipe1_6 <= product1;
        end
      end
    end // temp_process1

  always @* sum2_1 <= sumpipe1_1 + sumpipe1_2;

  always @* sum2_2 <= sumpipe1_3 + sumpipe1_4;

  always @* sum2_3 <= sumpipe1_5 + sumpipe1_6;

  always @ (posedge clk or posedge reset)
    begin: temp_process2
      if (reset == 1'b1) begin
        sumpipe2_1 <= 0.0000000000000000E+00;
        sumpipe2_2 <= 0.0000000000000000E+00;
        sumpipe2_3 <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          sumpipe2_1 <= sum2_1;
          sumpipe2_2 <= sum2_2;
          sumpipe2_3 <= sum2_3;
        end
      end
    end // temp_process2

  always @* sum3_1 <= sumpipe2_1 + sumpipe2_2;

  always @ (posedge clk or posedge reset)
    begin: temp_process3
      if (reset == 1'b1) begin
        sumpipe3_1 <= 0.0000000000000000E+00;
        sumpipe3_2 <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          sumpipe3_1 <= sum3_1;
          sumpipe3_2 <= sumpipe2_3;
        end
      end
    end // temp_process3

  always @* sum4_1 <= sumpipe3_1 + sumpipe3_2;

  always @ (posedge clk or posedge reset)
    begin: temp_process4
      if (reset == 1'b1) begin
        sumpipe4_1 <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          sumpipe4_1 <= sum4_1;
        end
      end
    end // temp_process4

  always @* sum_final <= sumpipe4_1;


  always @* output_typeconvert <= sum_final;


  always @ (posedge clk or posedge reset)
    begin: Output_Register_process
      if (reset == 1'b1) begin
        output_register <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          output_register <= output_typeconvert;
        end
      end
    end // Output_Register_process

  // Assignment Statements
  assign filter_out = $realtobits(output_register);
endmodule  // filter
